// Copyright Project Harbor Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dao

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/goharbor/harbor/src/jobservice/job"
	"github.com/goharbor/harbor/src/lib/orm"
	"github.com/goharbor/harbor/src/lib/q"
)

// NewTaskDAO returns an instance of TaskDAO
func NewTaskMysqlDAO() TaskDAO {
	return &taskMysqlDAO{}
}

type taskMysqlDAO struct {
	*taskDAO
}

func (t *taskMysqlDAO) Count(ctx context.Context, query *q.Query) (int64, error) {
	if query != nil {
		// ignore the page number and size
		query = &q.Query{
			Keywords: query.Keywords,
		}
	}
	qs, err := t.querySetter(ctx, query)
	if err != nil {
		return 0, err
	}
	return qs.Count()
}

func (t *taskMysqlDAO) List(ctx context.Context, query *q.Query) ([]*Task, error) {
	tasks := []*Task{}
	qs, err := t.querySetter(ctx, query)
	if err != nil {
		return nil, err
	}
	if _, err = qs.All(&tasks); err != nil {
		return nil, err
	}
	return tasks, nil
}

func (t *taskMysqlDAO) UpdateStatus(ctx context.Context, id int64, status string, statusRevision int64) error {
	ormer, err := orm.FromContext(ctx)
	if err != nil {
		return err
	}

	// status revision is the unix timestamp of job starting time, it's changing means a retrying of the job
	startTime := time.Unix(statusRevision, 0)
	// update run count and start time when status revision changes
	sql := `update task set run_count = run_count +1, start_time = ? 
				where id = ? and status_revision < ?`
	if _, err = ormer.Raw(sql, startTime, id, statusRevision).Exec(); err != nil {
		return err
	}

	jobStatus := job.Status(status)
	statusCode := jobStatus.Code()
	var args []interface{}
	now := time.Now()
	// when the task is in final status, update the end time
	// when the task re-runs again, the end time should be cleared, so set the end time
	// to null if the task isn't in final status
	if jobStatus.Final() {
		endTime := now
		args = []interface{}{status, statusCode, statusRevision, now, endTime,
			id, statusRevision, statusCode, statusRevision}
		sql = `update task set status = ?, status_code = ?, status_revision = ?, update_time = ?, end_time = ? 
		where id = ? and (status_revision = ? and status_code < ? or status_revision < ?) `
	} else {
		args = []interface{}{status, statusCode, statusRevision, now,
			id, statusRevision, statusCode, statusRevision}
		sql = `update task set status = ?, status_code = ?, status_revision = ?, update_time = ?, end_time = NULL 
		where id = ? and (status_revision = ? and status_code < ? or status_revision < ?) `
	}
	// use raw sql rather than the ORM as the sql generated by ORM isn't a "single" statement
	// which means the operation isn't atomic, this will cause issues when running in concurrency
	_, err = ormer.Raw(sql, args).Exec()
	return err
}

func (t *taskMysqlDAO) querySetter(ctx context.Context, query *q.Query) (orm.QuerySeter, error) {
	qs, err := orm.QuerySetter(ctx, &Task{}, query)
	if err != nil {
		return nil, err
	}

	// append the filter for "extra attrs"
	if query != nil && len(query.Keywords) > 0 {
		var (
			key       string
			keyPrefix string
			value     interface{}
		)
		for key, value = range query.Keywords {
			if strings.HasPrefix(key, "ExtraAttrs.") {
				keyPrefix = "ExtraAttrs."
				break
			}
			if strings.HasPrefix(key, "extra_attrs.") {
				keyPrefix = "extra_attrs."
				break
			}
		}
		if len(keyPrefix) == 0 {
			return qs, nil
		}
		inClause, err := orm.CreateInClause(ctx, fmt.Sprintf("select id from task where json_extract(extra_attrs, '$.%s') = ?",
			strings.TrimPrefix(key, keyPrefix)), value)
		if err != nil {
			return nil, err
		}
		qs = qs.FilterRaw("id", inClause)
	}

	return qs, nil
}
